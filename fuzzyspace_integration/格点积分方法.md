本文件为对 Sobereva 老师的 [密度泛函计算中的格点积分方法](http://sobereva.com/69) 一文前五个部分的重排版，用于我个人的学习，主要是用 LaTeX 重写了公式以及为代码加上了高亮以便阅读。本文件版权归 Sobereva 老师所有。



本文主要介绍密度泛函计算方法中的一个重要部分——格点积分方法，并给出具体的 Fortran 代码，同时讨论与之相关的问题。



## 1. 简介

在密度泛函（DFT）计算中，在计算交换相关能时，需要做这样一个积分 
$$
E_{XC}[\rho] = \int \epsilon(\rho(r)) dr,
$$
积分是对全空间进行的。在 Hartree-Fock 计算中涉及的单、双电子积分都是通过复杂推导，使积分充分简化，再进行精确数值积分。而 $E_{XC}[\rho]$ 这个积分不得不直接求解，以容忍一定的积分误差和效率的降低为代价。这一方面是由于  $\epsilon(r)$ 的函数形式往往十分复杂，难于通过推导简化；另一方面是交换相关泛函种类太多，目前就有百余种，如果使用一个通用的积分方法，以后新的交换相关泛函就能容易地加入程序中。另外，这个积分在其它计算中也常用到，比如电子的熵也可视为 $\rho(r)$ 的泛函，获得它要计算 
$$
S[\rho] = \int \frac{\rho(r)}{N} L_n(\frac{\rho(r)}{N}) dr,
$$
其中 $N$ 是体系总电子数。这类积分不仅理论意义重要，在实际中也明显影响 DFT 计算的速度，有不少文章对其计算方法进行了研究，试图寻找又快又准的方法，目前用得最多的方法就是本文要介绍的格点积分方法。

后文内容涉及数值积分的知识，若不了解，建议先看看数值方法书的插值求积方法部分，高斯积分在本文末的附录进行了介绍和讨论。



## 2. 积分的转化

对这个积分，Becke 在 1988 年提出了一种很好的解决办法[JCP 88,2547]，也是本文主要介绍的。后来又有人做过诸多改进以提高效率，但是基本原理没有改变。在更早之前虽然也有人对求解这类积分做过研究，比如 AIM 分析中的一些积分原子盆内函数值的算法，但用在 DFT 计算中效率都太低。

如何更有效率地积分一个函数，要分析函数本身的特点。交换相关泛函的行为主要决定于 $\rho(r)$ 的行为，例如形式最简单的交换泛函就是 Slater 提出的，被积函数为 $\rho(r)^{4/3}$。为了简便，下面直接将 $\rho(r)$ 作为被积函数来讨论。孤立原子电子密度在原子核处存在cusp，在核附近也很大，随着与原子核距离的增加近似呈指数衰减。在形成分子后，虽然电子密度发生了变形，但仍然可以用孤立原子电子密度的叠加来近似表达。即是说，虽然积分是全空间的，三个维度积分范围从负无穷到正无穷，但原子附近的区域需要更高的积分精度，所以直接使用笛卡尔坐标积分是很不明智的，最佳方法是以原子核为中心通过球极坐标积分，使原子附近有较高的积分格点密度，使更重要区域被更准确地积分。

当然，直接对每个中心进行球极坐标积分会使积分区间重复。最容易想到的解决办法是将分子空间划分为一个个原子空间，逐个积分再加和，于是可以将 
$$
\int F(\rho(r)) dr
$$
写为 
$$
\sum_i \int W_i(r) F(\rho(r)) dr,
$$
$W_i(r)$ 决定了哪些区域属于第 $i$ 个原子。划分的标准并不唯一，最简单的是通过 Voronoi 多面体方式划分，二维情况如下图所示：
![2D Voronoi](http://sobereva.com/usr/uploads/image/20150610/20150610195837_58806.gif)

在每两个原子间做中垂面，围出来的一个个多面体就是原子的空间。当然，垂面的位置也可以根据原子半径进行一定调整。对于这种离散的划分方法，在积分第 $i$个中心时，当 $r$ 处于 $i$ 原子空间内有 $W_i(r)=1$, 当 $r$ 处于 $i$ 原子空间外有 $W_i(r)=0$. 

但是这种离散的划分在实际计算中有所不妥，因为下一节介绍的单中心积分最适合光滑、连续的函数，而这种划分得出的被积函数 $W_i(r) \cdot F(\rho(r))$ 在被截处呈阶梯状，不满足这个条件，所以积分并不准确。Becke 提出的是模糊的划分方法。首先考虑双原子情况，编号一个为 $a$ 一个为 $b$，以 $a$ 为参考原子，定义 $\mu(a,b) = \frac{(r_a - r_b)}{R(a,b)}$, 其中 $r_a$, $r_b$ 分别为空间某点到 $a$, $b$ 原子核的距离，$R(a,b)$ 是 $a$, $b$ 原子核间距离。所有 $\mu(a,b)=0$ 的点，即所有 $r_a=r_b$ 的点，构成了 $a$, $b$ 原子间中垂面，在 $a$ 原子这半边 $-1 \le \mu <0$, 在 $b$ 原子这半边 $0 < \mu \le 1$。如果以 $r$ 处的 $\mu(a,b)$ 是否大于 0 作为 $W_a(r)$ 等于0或1的判据，则又回归到离散的划分。

若使离散的划分变为模糊的划分，也就是允许原子空间之间可以有交叠，但保证 
$$
\sum_i W_i(r)=1,
$$
就有可能让被积函数平滑，使积分精度增加。现在定义一个函数 
$$
p(\mu)=1.5\mu-0.5 \mu^3,
$$
然后定义 
$$
s(\mu)=\frac{1}{2}(1-p(\mu)),
$$
$s(\mu)$ 的图形如下图 $k=1$ 的曲线所示。如果对 $p(\mu)$ 先进行迭代再代入 $s(\mu)$，比如说迭代两次，就得到 
$$
s(\mu)=\frac{1}{2}[1-p(p(p(\mu)))],
$$
其函数图形就是下图的 $k=3$，每迭代一次 $k$ 就增加1。从图可见，迭代次数越多图形在 $\mu=0$ 处变化越陡，或者说越不光滑。当 $k=\infty$ 时就还原为了前面提到的离散划分。所以，选取一个不很大的 $k$ 值（Becke 建议用 $k=3$），将相应的 $s(\mu)$ 作为 $W(\mu)$ 就使得空间被模糊地划分了，在参考中心处格点权重为 1，延伸到相邻原子处格点权重为 0，在二者之间权重函数平滑过渡。由于 $F(\mu(r))$ 和 $W_i(r)$ 都是光滑的，所以在单中心积分时的被积函数 $W_i(r) \cdot F(\mu(r))$ 也是光滑的，能够容易地被较精确地积分。

![mu_func](http://sobereva.com/usr/uploads/image/20150610/20150610195845_95823.gif)

对多原子情况，某个位置上第 $i$ 个原子的实际权重等于在此处原子 $i$ 与所有其它原子 $j$ 之间权重的乘积，即 $W_i(r)= \prod_{i \neq j} s(\mu(i,j))$, 注意 $\mu(i,j)$ 是 $r$ 的函数。所以当某原子被其它原子包围时，只有它附近一定区域内其权重数值比较大，离它越远处属于它的成分就越小。如果 $s(\mu(i,j))$ 使用的是前面离散划分的话，即 $\mu(i,j)$ 小于 0 和大于 0 时 $s$ 分别为 1 和 0，则 $W_i(r)=1$ 的区域就是第 $i$ 个原子的 Voronoi 胞腔。空间的模糊划分方法并不仅有 Becke 提出的这一种，例如 Hirshfeld 划分也是比较著名的[TCA 44,129], 并且有明确的物理意义，原本用在计算 Hirshfeld 电荷上，笔者认为也完全可以用于密度泛函积分当中，但目前未见报道。

最后，为了满足 $\sum_i W_i(r)=1$ 条件，还需要做归一化：
$$
W_i(r)=W_i(r) / \sum_{j} W_j(r).
$$
这样就获得了最终的 $W_i$.



## 3. 单中心球极坐标的积分

### 3.1 简介

此节讨论怎么求单中心球极坐标积分 
$$
\int W_i(r) \cdot F(\rho(r))dr.
$$
为了省事，简写为 $\int f(r)dr$. 为避免混淆，本文中大写的 $W_i$ 是指的空间划分时的权重系数，小写的 $w_i$ 是指的单中心积分时的权重系数。

在球极坐标下，此积分写为：
$$
\int_{0}^{2 \pi} \int_{0}^{\pi} \int_{0}^{\infty} [r^2 f(r) sin(\theta) ] d r d \theta d \varphi 
$$
其中 $r$ 是径向坐标。选取适当的正交多项式，对被积函数进行变换，做三重高斯积分就能得到结果。将 $r^2f(r) sin(\theta) $ 简写为 $q(r, \theta, \varphi)$, 则实际计算时的形式为：
$$
\int_{0}^{2 \pi} \int_{0}^{\pi} \int_{0}^{\infty} q(r, \theta, \varphi) dr d \theta d \varphi  =  \sum_{k} \sum_{j} \sum_{i} A_k A_j A_i q(r_i, \theta_j, \varphi_k)
$$
其中 $A_i, A_j, A_k$ 代表积分径向、$\theta$ 部分、$\varphi$ 部分时的积分节点的权重系数，$(r_i, \theta_j, \varphi_k)$ 代表相应的求积节点的位置。在实际计算中，事先把三个积分分量的权重系数乘在一起成为 $A_{i,j,k}$ 并保存在一个数组里，比如叫 weight；然后将相应的求积节点位置由球极坐标转换为笛卡尔坐标：
$$
x=r sin(\theta) cos(\varphi) \\
y=r sin(\theta) sin(\varphi) \\
z=r cos(\theta) \\
$$
并保存在数组里，比如叫 coord。积分就成了
$$
\sum_{i} weight(i) \cdot coord(i),
$$
计算十分简单。这两个数组的大小就是三个积分方向的积分节点数的乘积，比如 $\varphi$ 用 32 个点, $\theta$ 用 16 个点（因为积分范围比 $\varphi$ 小一倍，所以一半的点数），$r$ 用 75 个点，则总共要算 $16 \times 32 \times 75=38400$ 个点。

然而这样将 $\theta$ 和 $\varphi$ 部分独立积分的效率并不高。实际上对于单位球面积分有不少人专门做了研究，若不将 $\theta$ 和 $\varphi$ 分离，而是一起考虑，可以用更少的点达到相同的积分精度。所以只需要把原积分变量 $r$ 分离为径向和角度两部分即可，即
$$
\int f(r) dr = \int  \int  f(r) R^2 d \Omega dR.
$$
（我怀疑这里 Sobereva 老师有个笔误，右端被积函数应该是 $f(\Omega) R^2$.）

下面具体来看如何积分角度部分，积分通式为 $\int q(\Omega) d \Omega.$

### 3.2 角度部分积分

积分单位球面（半径 $R=1$）目前用得最普遍的是 Lebedev 提出的方法，也是将  $\int q(\Omega) d \Omega$ 转化成积分节点和权重的乘积，即 
$$
 \int q(\Omega) d \Omega = \sum_{i} A_i q(\Omega_i)
$$
Lebedev 在一系列文章中陆续给出了能精确积分越来越高阶球谐函数的积分节点和权重，随着积分精度增加积分节点数也随之增加，从最小的可精确积分 $l=3$ 的球谐函数的 6 个节点，到最多的可精确积分 $l=131$ 的球谐函数的 5810 个节点，可根据对精度的要求从中选择合适的节点数。Lebedev 系列的节点位置和权重都具有反演和八面体旋转不变性的特点。

有位活雷锋写了个 Lebedev-Laikov.F 发布到了 CCL 上供大家使用，其中的子程序用于生成 Lebedev 积分节点坐标和权重系数，见：[http://www.ccl.net/cca/software/SOURCES/FORTRAN/Lebedev-Laikov-Grids/](http://www.ccl.net/cca/software/SOURCES/FORTRAN/Lebedev-Laikov-Grids/)
在 Lebedev-Laikov.F 中，生成节点的子程序名字都以 LD 开头，后面接着生成的点数，比如 LD0170 生成 170 个点，LD5294 生成 5294 个点。对称唯一部分的节点的信息是以列表方式储存的，然后会通过 GEN_OH 子程序生成对称部分的点。下面是生成 110 个 Lebedev 节点信息的示例程序：

```fortran
program ltwd
    integer,parameter :: num=110
    real*8,dimension(num) :: x,y,z,w
    call LD0110(X,Y,Z,W,N)  // 传入容量与节点数相同的一维数组接收结果。最后一个参数没什么用，随便传进一个整数即可，返回值就是生成的节点数。
    do i=1,num
        write(1,"(4f15.10)") x(i),y(i),z(i),w(i)
    end do
end

```

运行之后节点信息会保存在当前路径下 fort.1 中。作散点图，如下所示：
![LD110](http://sobereva.com/usr/uploads/image/20150610/20150610195901_35463.gif)

所有点的距离与原点都为 1。权重系数已归一化，即 $\sum w_i =1$, 也因此最后的结果要乘以 $4 \pi$. 因为若被积函数是常数 1，即每个积分节点函数值为 1，乘上权重加和值为 1，但实际值是 $4\pi$（半径为 1 的球面表面积为 $4 \pi$）。

用 Lebedev 格点积分球面虽然比分别积分 $\varphi$ 和 $\theta$ 部分效率更高，但也有一点点缺点，即可选的积分节点数目是离散的，比如要么取 350 个点，要么取 434 个点，没法取 350 至 434 之间的值；而且节点数有上限，Lebedev-Laikov.F 里最多只有5810个点的情况，再多就没办法了。而 $\varphi$ 和 $\theta$ 独立积分时节点数设定是很随意的，且积分节点和权重可以很容易地自行算出。在一些量子化学程序里角度部分积分同时支持这两种情况，比如 Gaussian 里自定义格点通过 `int=grid=mmmnnn` 指定，`mmm` 指的是径向节点数，`nnn` 是角度积分的 Lebedev 节点数（最多 974 个），如 75434 代表共 $75 \times 434=32550$ 个点。如果写的是 `-mmmnnn`, 则 $nnn$ 指的是 $\theta$ 的点数，$\varphi$ 的点数为$2nnn$, 如 `-96032` 代表共 $96 \times 32 \times 64=196608$ 个点。

### 3.3 径向部分积分

接下来具体介绍下径向部分的积分，也就是求 
$$
\int_{0}^{\infty} r^2 q(r) dr.
$$
径向部分的积分的方法很多，也被不同程序所采纳（据悉 Gaussian 用的是 Euler-Maclaurin 积分），多数是基于高斯积分，可参看 JCC 24,732。在使用不同正交多项式做高斯积分时需要对被积函数做不同变换，但用哪种高斯积分更准确难有定论，在不同情况下精度相对高低并不一定。Becke 最初用的是第二类 Chebyshev 多项式做高斯积分，这种径向积分方法用在实际计算中即便不是最好，但至少也不错，下面将具体介绍。

从本文附录中看到，用第二类 Gauss-Chebyshev 积分时权重函数应当为 $(1-x^2)^{0.5}$, 被积区间应该为 $[-1,1]$，然而这与当前要积分的函数形式和区间都不符。所以需要变换，$x \in [-1,1]$ 与 $R \in [0, \infty)$ 之间可以用这个式子转化
$$
R=P\frac{1+x}{1-x},
$$
其中 $P$ 是某个常数，也可以先把它当成 1，在后文才会涉及。

将 $R=P\frac{1+x}{1-x}$ 代入$\int_{0}^{\infty} R^2 q(R) dR$, 因 $dR=\frac{2P}{(1-x)^2} dx$, 故原式等于
$$
\int_{-1}^{1} 2 P^3 \frac{(1+x)^2}{(1-x)^4} q(R) dx
$$
现在还没有积分时需要的权重函数 $(1-x^2)^{0.5}$, 但可以变换出来，式中的 
$$
\begin{aligned}
\frac{(1+x)^2}{(1-x)^4} &=  \frac{(1+x)^{1.5}}{(1-x)^{4.5}} \cdot (1+x)^{0.5} \cdot (1-x)^{0.5} \\
                        &= \frac{(1+x)^{1.5}}{(1-x)^{4.5}} \cdot (1-x^2)^{0.5}
\end{aligned}
$$
故原式等于
$$
\int_{-1}^{1} 2 P^3 \frac{(1+x)^{1.5}}{(1-x)^{4.5}} q(R) (1-x^2)^{0.5} dx
$$
由于 $(1-x^2)^{0.5}$ 是权重函数，所以实际被积函数就是 
$$
2 P^3 \frac{(1+x)^{1.5}}{(1-x)^{4.5}} q(R).
$$
将积分节点 $x_i$ 代入上式并乘上相应根的权重系数 $w_i$ 加和即可，即原式等于
$$
\sum_{i} 2 P^3 \frac{(1+x_i)^{1.5}}{(1-x_i)^{4.5}} q(R_i) w_i,
$$
其中 $R_i = P \frac{1 + x_i}{1 - x_i}$. $n$ 阶（即 $n$ 个根）第二类 Chebyshev 多项式的每个根（即积分节点）与权重系数分别为：
$$
x_i = cos(\frac{i \pi}{n+1}), \\
w_i = \frac{\pi}{n+1} sin^2(\frac{i \pi}{n+1}).
$$


为了计算时方便，上式可再转化一下。由于
$$
1-x_i^2 = 1 - cos^2(\frac{i \pi}{n+1}) = sin^2(\frac{i \pi}{n+1})
$$
所以
$$
w_i = \frac{\pi}{n+1}(1 - x_i^2) = \frac{\pi}{n+1}(1-x_i)(1+x_i)
$$
代入原式，即得：
$$
\sum_{i} \frac{2 \pi}{n+1} P^3 \frac{(1+x_i)^{2.5}}{(1-x_i)^{3.5}} q(R_i)
$$
可以将 $q(R_i)$ 前面的这一串一起作为新的权重系数 $\omega_i$，所以最终有
$$
\begin{aligned}
\int R^2 q(R) dR &= \sum_{i} \omega_i q(R_i) \\
\omega_i &= \frac{2 \pi}{n+1} P^3 \frac{(1+x_i)^{2.5}}{(1-x_i)^{3.5}} \\
R_i &= P \frac{1 + x_i}{1 - x_i}, \\
x_i &= cos(\frac{i \pi}{n+1})
\end{aligned}
$$
推导完毕。



## 4. 积分格点的调整

通过对积分格点进行调整，能使积分更有效率。

由于不同元素的原子半径不同，格点分布应当做相应调整。在 $R_i= P\frac{1+x_i}{1-x_i}$ 式子中，可见 $P$ 为第二类 Gauss-Chebyshev 积分在积分区间中点 $(x=0)$ 处 $R$ 的值，Becke 认为 $P$ 应当设为原子共价半径的一半（对于氢，只设为原子共价半径），这样原子共价半径越大，径向格点分布将越往外延展，可以更好涵盖电子密度较大的区域。


$s(\mu)$ 函数在自变量等于 0, 即两原子中垂面处为 0.5, 这个中垂面位置也应当根据原子共价半径做适当调整。为此，Becke 将 $s(\mu(i,j))$ 的自变量替换为 $\nu(i,j)$, 它与 $\mu(i,j)$ 的关系为：$\nu(i,j)=\mu(i,j)+a(i,j) (1- \mu(i,j)^2)$, 目的就是找一个 $a(i,j)$, 当 $r_i/r_j=R_i:R_j=\chi(i,j)$ 时 $\nu(i,j)$ 恰为0, 其中 $R_i$ 和 $R_j$ 为 $i,j$ 原子共价半径。为此，先令 $\nu(i,j)=0$, 则 $a(i,j)=\frac{\mu(i,j)}{\mu(i,j)^2-1}$, 在 $r_i/r_j=R_i:R_j$ 时，$\mu(i,j)=(r_i-r_j)/R(i,j)=(r_i-r_j)/(r_i+r_j)=\frac{\chi(i,j)-1}{\chi(i,j)+1}$, 因此 $a(i,j)$ 就确定了。推导中假设格点在 $i,j$ 轴线上，所以 $R(i,j)=r_i+r_j$. 当 $a(i,j)$ 小于 $-0.5$ 和大于 $0.5$ 时直接分别设为 $-0.5$ 和 $0.5$。笔者发现，若将所有原子设成具有相同数目的径向和角度格点，则做上述调整只会令积分精度下降，只有如下对不同原子用不同格点数目时上述调整才会提高积分精度。Becke 用的是 Bragg-Slater 共价半径，但其中氢的半径为 $0.25$ 埃，用于调整格点时显得有些过小，为得到更好结果，Becke 将之改为 0.35 埃。


对于主量子数小的原子，可以用更少的径向格点以提高计算速度。经笔者实践，对 $n=1$ 的原子用 35 个径向格点，每增加一个壳层增加 15 个格点比较合适。由于在内侧的原子周围电子密度变化比处于边缘的原子更为复杂，所以应当用更多的格点积分角度部分，边缘原子使用 230 个 Lebedev 节点、内侧原子使用 434 个 Lebedev 节点比较合适，同时内侧原子也最好增加 15 个径向格点。这样设定已经有很高的积分精度了，如果要求更高，可以再提高格点数目。


经过上述步骤生成的格点还可以进行裁剪（grid pruning），在确保积分精度不明显下降的情况下合理地去掉一部分格点可以节省计算时间。裁剪方法很多，例如径向节点会有一部分点距离中心非常远，虽然这些点权重很大，但是函数数值极小，对结果的贡献微乎其微，若将距离积分中心超过 10 bohr 的格点一律忽略（也可以根据原子半径来调整此标准），一般能节省五分之一的计算量，至少对于第三周期及以下的原子的结果几乎没有影响。再比如，离原子核较近的内层电子受分子环境影响小，所以离原子近的 $\rho(r)$ 比中等距离处的 $\rho(r)$ 更接近球对称分布、变化得更平滑，所以可以对内侧区域用更少的格点做角度部分积分。在 Gaussian 程序中的 fine 格点是每个原子径向部分用 75 个点，角度部分最多 302 个点做积分，原本共 22650 个点，经过自动裁剪后只剩约 7000 多个点，仅是之前的约三分之一。


如何调整、裁剪格点任意性比较强，因此有人提出了标准化的格点设定方法，例如 SG-1, SG-0 格点。使用这些格点时，角度、径向积分方法是指定的，每种元素的所用格点设定也是事先优化好的，在相同数目格点下用这样的标准格点一般能得到比随意地调整、裁剪更好的积分效果。例如使用 SG-1 格点设定时，径向应使用 Euler-Maclaurin 积分，角度应使用 Lebedev 积分，所有原子径向都是 50 个点，角度部分格点数取决于格点的径向坐标，离被积中心从近到远角度格点数分为 6、38、86、194、86 五个部分，分界位置取决于原子所在周期（在原文中有列表，通过考察对能量的影响获得）。无论原子的元素类型、在内侧或者在边缘，每个原子都是大约 3700 个点，不做任何额外的格点调整与裁剪。SG-1 格点结果十分接近更昂贵的径向 50、角度 194 格点的结果，对中等体系误差一般低于 0.0003 a.u.，当然现在来看 SG-1 格点积分精度不高，但由于计算量小，计算大体系是合适的。后来提出的 SG-0 格点中径向积分改成了更好的 MultiExp 方法，角度格点数分界设定被更加细化，每个原子仅有约 1500 个点，虽然精度只是 SG-1 的一半，但是计算速度也快了一倍，对于诸如生物大分子体系的预计算是很合适的。

如果被积函数的行为比较有特点，最好根据其特点调整格点设定，上文已隐含地体现了这一点，比如拉普拉斯值函数由于在原子核附近剧烈波动，相对于径向变化相对平滑的 $\rho(r)$, 用更多的径向格点往往能使结果改进得更多。



## 5. 积分代码

这个子程序是笔者的 Multiwfn 程序中的一部分，出于本文的目的做了一定简化，是上述算法的具体实现，用来积分一个体系的 $\rho(r)$, 由此可以更清楚地了解计算流程。此程序用到了一些外部变量和子程序，在注释中已说明。

```fortran
subroutine intfunc
use function !引用外部变量与函数
use util
implicit real*8 (a-h,o-z)
real*8,allocatable :: potx(:),poty(:),potz(:),potw(:) !接收Lebedev格点位置和权重的数组
type(content),allocatable :: gridatm(:)    !content类型在别处定义的，包含x,y,z,value四个元素，都是real*8。gridatm储存格点位置和权重
real*8 smat(ncenter,ncenter),Pvec(ncenter) !ncenter是总原子数。smat储存s(ν(i,j))，Pvec储存归一化前的w_i(r)
integer :: bondmat(ncenter,ncenter) !成键矩阵记录两个原子间是否成键，成键为1，不成键为0

maxsph=434 !假设角度部分最多有434个格点
maxrad=80 !假设径向最多有80个格点
allocate(potx(maxsph),poty(maxsph),potz(maxsph),potw(maxsph),gridatm(maxrad*maxsph))

!生成成键矩阵，原子成键数超过1就说明是内部原子，要用更多格点。
bondmat=0
do i=1,ncenter
    do j=i+1,ncenter
        ! distmat是已算好的距离矩阵。covr第n个元素是周期表中原子序数为n的共价半径。这里用的共价半径来自Dalton Trans. 2008,2832。a(i)%index是第i个原子的原子序数。
        if ( distmat(i,j) < 1.15D0*(covr(a(i)%index)+covr(a(j)%index)) ) bondmat(i,j)=1
    end do
end do
bondmat=bondmat+transpose(bondmat) !成键矩阵是对称的

rintval=0 !这是将被累加的变量，由于储存最终的积分值
covr(1)=0.35D0/b2a !对氢原子用0.35埃的共价半径。由于covr记录的是以波尔为单位，用b2a=0.529177249转换单位。
call cpu_time(time_begin) !用于计算总耗时，便于研究积分格点设置与计算精度的关系。

do iatm=1,ncenter !循环每个原子
    write(*,"(' Processing center',i6,'(',a2')')") iatm,a(iatm)%name !a(iatm)%name是被积分的原子的元素名
    if (a(iatm)%index<=2) then
        radpot=35 !设定径向格点数。radpot是外部定义的整数变量。
    else if (a(iatm)%index<=10) then
        radpot=50
    else
        radpot=65
    end if
    if (sum(bondmat(iatm,:))==1) then !判断此原子是在内侧还是边缘
        sphpot=230 !设定角度部分格点数。sphpot是外部定义的整数变量。
    else
        sphpot=434 !内侧的原子更多的径向和角度格点
        radpot=radpot+15
    end if
    if (sphpot==230) call LD0230(potx,poty,potz,potw,isphnum) !生成以0,0,0为原点，在半径为1的球面上分布的Lebedev格点坐标。
    if (sphpot==434) call LD0434(potx,poty,potz,potw,isphnum)

    iradcut=0 !径向格点与参考中心的距离随径向格点序号增加而递减，径向格点中序号在iradcut及之前的点将被扔掉以节省时间。
    parm=covr(a(iatm)%index)/2 !parm指的是前文(1+x_i)/(1-x_i)*P中的P
    if (a(iatm)%index==1) parm=covr(a(iatm)%index) !对氢原子半径不除以2
    do i=1,radpot !循环每一径向壳层。将第二类Gauss-Chebyshev积分的权重和Lebedev角度积分的权重组合。并生成每个点的笛卡尔坐标。
        radx=cos(i*pi/(radpot+1)) !生成radpot阶第二类Chebyshev多项式的每个根，即前文的x_i。pi是外部定义的π的数值
        radr=(1+radx)/(1-radx)*parm !由x_i生成R_i，也就是径向积分的节点
        radw=2*pi/(radpot+1)*parm**3 *(1+radx)**2.5D0/(1-radx)**3.5D0 *4*pi !径向积分的权重系数，顺便把球面积分时要乘的4*π也乘了进去。
        gridatm( (i-1)*sphpot+1:i*sphpot )%x=radr*potx !一次设定一层节点的坐标和权重。径向坐标radr乘上以0,0,0为原点的单位球面上的Lebedev点的笛卡尔坐标，得到的就是在半径为radr的球面上的Lebedev点的笛卡尔坐标。
        gridatm( (i-1)*sphpot+1:i*sphpot )%y=radr*poty
        gridatm( (i-1)*sphpot+1:i*sphpot )%z=radr*potz
        gridatm( (i-1)*sphpot+1:i*sphpot )%value=radw*potw !将径向和角度部分的权重函数组合。
        if (iradcut==0.and.radr<10) iradcut=i-1 !大于radr的R_i将被截掉，记录在编号为何值时截断
    end do

    !当前积分节点是以0,0,0为中心，下面将中心转移到被积原子上
    gridatm%x=gridatm%x+a(iatm)%x
    gridatm%y=gridatm%y+a(iatm)%y
    gridatm%z=gridatm%z+a(iatm)%z
    do i=1+iradcut*sphpot,radpot*sphpot !从不被截掉的节点开始循环每个节点
        rnowx=gridatm(i)%x !为了写的时候方便，改用rnowx,rnowy,rnowz表示
        rnowy=gridatm(i)%y
        rnowz=gridatm(i)%z
        rfuncval=fdens(rnowx,rnowy,rnowz) !fdens是外部函数，计算此点的被积函数值，这里就是指ρ(r)。

        !计算这个格点的空间划分权重W_i
        smat=1.0D0
        do ii=1,ncenter !为计算所有的s(ν(i,j))，循环每一对儿原子
            ri=dsqrt( (rnowx-a(ii)%x)**2+(rnowy-a(ii)%y)**2+(rnowz-a(ii)%z)**2 ) !计算r_i
            do jj=1,ncenter
                if (ii==jj) cycle !s矩阵对角元没用，不重新赋值，值仍为1。
                rj=dsqrt( (rnowx-a(jj)%x)**2+(rnowy-a(jj)%y)**2+(rnowz-a(jj)%z)**2 ) !计算r_j
                rmiu=(ri-rj)/distmat(ii,jj) !计算μ(i,j)

                !根据原子半径调整原子空间划分，也就是将μ(i,j)转化为ν(i,j)
                chi=covr(a(ii)%index)/covr(a(jj)%index) !计算χ(i,j)
                uij=(chi-1)/(chi+1)
                aij=uij/(uij**2-1)
                if (aij>0.5D0) aij=0.5D0
                if (aij<-0.5D0) aij=-0.5D0
                rmiu=rmiu+aij*(1-rmiu**2) !此时的rmiu就是ν(i,j)

                tmps=1.5D0*(rmiu)-0.5D0*(rmiu)**3 !做三次迭代
                tmps=1.5D0*(tmps)-0.5D0*(tmps)**3
                tmps=1.5D0*(tmps)-0.5D0*(tmps)**3
                smat(ii,jj)=0.5D0*(1-tmps) !得到s(ν(i,j))=0.5(1-p(p(p(ν(i,j)))))
             end do
        end do 
        Pvec=1.0D0
        do ii=1,ncenter !计算W_i(r)=∏[i/=j]s(μ_i,j)。注意因为现在smat对角元为1，乘它等于没乘
             Pvec=Pvec*smat(:,ii)
        end do
        weight=Pvec(iatm)/sum(Pvec) !做归一化，得到最终的W_i(r)
        rintval=rintval+rfuncval*weight*gridatm(i)%value !原子空间划分权重weight和单中心积分权重gridatm(i)%value之积就是此点的总权重。总权重乘上此点被积函数值，对所有中心的所有节点累加，最终得到的就是积分结果。
    end do
end do

!显示用时和最终结果
call cpu_time(time_end)
write(*,"(' Totally evaluated',i10,' points',' took',f8.2,' seconds')")    icount,time_end-time_begin
write(*,*)
write(*,"(' Final result:',f20.10)") rintval
end subroutine
```

以 3-21G 下计算的一氟乙烷为例，积分电子密度期望值为 26，实际积分值为 26.0000073079，还是很准确的。在 Multiwfn 里也可以积分拉普拉斯函数，期望值为 0，此体系中积分值为 -0.0006034985，也还是不错的。若将所有原子都用径向 75、角度 770 个点，积分电子密度结果为 25.9999996466，积分拉普拉斯值函数结果为 -0.0000250146，精度都提高了一位，但速度也慢了，要计算的点数从 92130 增加到了 211792。注意由于Multiwfn 读入的 .wfn 文件有效数字只有 7、8 位，与期望值的偏差很大程度是由于输入精度不够高造成。为了代码简洁易懂，上面代码的格点设定没有做充分的优化，大家可尝试对不同径向壳层使用不同数目的角度格点以增加积分效率。

在 KS-DFT 计算中为了获得 KS 算符矩阵元，需要算这样一个积分：
$$
V_{ij} = \int \eta_i(r) V(r) \eta_j(r) dr,
$$
其中 $V(r)$ 是交换相关势，$\eta_i$ 是第 $i$ 个基函数。积分方法与前述完全一样，只不过是将被积函数由 $\epsilon(\rho(r))$ 改成 $\eta_i(r) V(r) \eta_j(r)$ 而已。由于矩阵元很多，这个积分也要算很多次，会很慢。但可以事先把 $V(r)$ 和各个 $\eta_i(r)$ 在积分格点上的值存起来，算不同的矩阵元的时候调用相应的已算好的值即可，速度就很快了。
